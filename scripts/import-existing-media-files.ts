import { getPayload } from 'payload'
import config from '../payload.config'
import dotenv from 'dotenv'
import path from 'path'
import fs from 'fs'
import { createReadStream } from 'fs'

dotenv.config()

/**
 * Import existing media files from the media directory into Payload CMS
 *
 * This script scans the media directory and creates Payload media records
 * for all image files that don't already have records.
 */
const importExistingMediaFiles = async () => {
  console.log('ğŸš€ Importing existing media files into Payload CMS\n')

  const mediaDir = path.resolve(process.cwd(), 'media')

  let payload: any

  try {
    // Initialize Payload CMS
    console.log('ğŸ“¦ Initializing Payload CMS...\n')
    payload = await getPayload({ config })
    console.log('âœ… Payload CMS initialized\n')

    // Check media directory
    console.log('ğŸ“ Scanning media directory...\n')
    if (!fs.existsSync(mediaDir)) {
      console.error(`âŒ Media directory not found: ${mediaDir}`)
      process.exit(1)
    }

    // Get all image files (excluding auto-generated thumbnails)
    const allFiles = fs.readdirSync(mediaDir)
    const imageFiles = allFiles.filter(file => {
      const ext = path.extname(file).toLowerCase()
      const isImage = ['.jpg', '.jpeg', '.png', '.gif', '.webp', '.svg'].includes(ext)

      // Exclude auto-generated thumbnails (files with size suffixes like -400x300.jpg)
      const isAutoGenerated = file.match(/-\d+x\d+\.(jpg|jpeg|png|gif|webp)$/i)

      return isImage && !isAutoGenerated
    })

    console.log(`   Found ${imageFiles.length} original image files to import\n`)

    // Get existing media records
    const { docs: existingMedia } = await payload.find({
      collection: 'media',
      limit: 10000,
    })

    const existingFilenames = new Set(existingMedia.map((m: any) => m.filename))
    console.log(`   Found ${existingMedia.length} existing media records\n`)

    // Filter out files that already have records
    const filesToImport = imageFiles.filter(file => !existingFilenames.has(file))
    console.log(`   ${filesToImport.length} files need to be imported\n`)

    if (filesToImport.length === 0) {
      console.log('âœ… All files already imported!')
      return
    }

    // Import files
    console.log('ğŸ“¸ Importing media files...\n')

    let imported = 0
    let errors = 0
    const errorLog: string[] = []

    for (const filename of filesToImport) {
      try {
        const filePath = path.join(mediaDir, filename)
        const stats = fs.statSync(filePath)

        // Determine category based on filename patterns
        let category = 'General'
        if (filename.includes('album-art') || filename.includes('album_art')) {
          category = 'Podcasts'
        } else if (filename.match(/\.(jpg|jpeg|png)$/i) &&
                   (filename.includes('member') || filename.includes('dj') ||
                    filename.includes('volunteer'))) {
          category = 'Member Profile Images'
        } else if (filename.includes('event') || filename.includes('poster')) {
          category = 'Events'
        } else if (filename.includes('shop') || filename.includes('shirt') ||
                   filename.includes('onesie')) {
          category = 'Shop Items'
        } else if (filename.includes('ad')) {
          category = 'Advertisements'
        }

        // Read file into buffer
        const fileBuffer = fs.readFileSync(filePath)

        // Create media record via Payload API
        const result = await payload.create({
          collection: 'media',
          data: {
            alt: filename
              .replace(/\.[^/.]+$/, '') // Remove extension
              .replace(/[-_]/g, ' ') // Replace - and _ with spaces
              .replace(/\b\w/g, (l: string) => l.toUpperCase()), // Capitalize words
            category: category,
          },
          file: {
            data: fileBuffer,
            mimetype: getMimeType(filename),
            name: filename,
            size: stats.size,
          },
        })

        imported++
        console.log(`   âœ… [${imported}/${filesToImport.length}] Imported: ${filename} (${category}) - ID: ${result.id}`)

        // Add small delay to avoid overwhelming the system
        if (imported % 10 === 0) {
          await new Promise(resolve => setTimeout(resolve, 500))
        }

      } catch (error: any) {
        errors++
        const errorMsg = `   âŒ Failed to import ${filename}: ${error.message}`
        console.error(errorMsg)
        errorLog.push(errorMsg)

        // Continue with next file
        continue
      }
    }

    // Summary
    console.log('\n' + '='.repeat(70))
    console.log('âœ¨ Media Import Complete!')
    console.log('='.repeat(70))
    console.log(`\nğŸ“Š Summary:`)
    console.log(`   Total files found:     ${imageFiles.length}`)
    console.log(`   Already imported:      ${existingMedia.length}`)
    console.log(`   Newly imported:        ${imported}`)
    console.log(`   Errors:                ${errors}`)
    console.log()

    if (errors > 0) {
      console.log('âš ï¸  Errors encountered:')
      errorLog.forEach(err => console.log(err))
      console.log()
    }

    console.log('ğŸ“ Next Steps:')
    console.log('   1. ğŸŒ Access admin panel: http://localhost:3000/admin/collections/media')
    console.log('   2. ğŸ–¼ï¸  Verify that images display correctly')
    console.log('   3. âœ“  Update content to reference these media files\n')

  } catch (error) {
    console.error('\nâŒ Import failed:', error)
    process.exit(1)
  } finally {
    process.exit(0)
  }
}

function getMimeType(filename: string): string {
  const ext = path.extname(filename).toLowerCase()
  const mimeTypes: Record<string, string> = {
    '.jpg': 'image/jpeg',
    '.jpeg': 'image/jpeg',
    '.png': 'image/png',
    '.gif': 'image/gif',
    '.webp': 'image/webp',
    '.svg': 'image/svg+xml',
  }
  return mimeTypes[ext] || 'application/octet-stream'
}

importExistingMediaFiles()
